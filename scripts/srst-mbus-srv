#!/usr/bin/env python2
# poll modbus/TCP host (multi-threads for manage TCP links)
# design to use data from/to SQL database

import pymysql.cursors
import time
from pyModbusTCP.client import ModbusClient
from threading import Thread, Event, Lock

# some consts
# DB
DB_HOST = 'localhost'
DB_USER = 'srst-mbus'
DB_PWD = 'sup_rst'
DB_NAME = 'sup_rst'
# misc
MBUS_REFRESH = 30


# some class
class NodeList(object):
    nodes = {}
    threads = {}

    @staticmethod
    def update_list(new_list):
        # search add or update from new_list
        for hid in new_list:
            # host_id already exist ?
            if hid in dict(NodeList.nodes):
                if new_list[hid] != NodeList.nodes[hid]:
                    NodeList._update(hid, new_list[hid])
            else:
                NodeList._add(hid, new_list[hid])
        # search for nodes remove from new_list
        for hid in dict(NodeList.nodes):
            if hid not in new_list:
                NodeList._remove(hid)

    @staticmethod
    def _add(hid, d_params):
        print('add hid %i' % hid)
        NodeList.nodes[hid] = d_params
        # create thread
        NodeList.threads[hid] = NodeThread(NodeList.nodes[hid])
        NodeList.threads[hid].start()

    @staticmethod
    def _update(hid, d_params):
        print('update hid %i' % hid)
        NodeList.nodes[hid] = d_params
        # update thread
        NodeList.threads[hid].update(NodeList.nodes[hid])

    @staticmethod
    def _remove(hid):
        print('remove hid %i' % hid)
        del NodeList.nodes[hid]
        # stop thread
        NodeList.threads[hid].stop()


class NodeThread(Thread):
    def __init__(self, node_data):
        # init thread
        Thread.__init__(self)
        self.daemon = True
        # private
        self._is_run = True
        self._end_evt = Event()
        self._node = dict(node_data)
        self._node_lock = Lock()

    def get_node(self, key):
        with self._node_lock:
            return self._node[key]

    def set_node(self, key, value):
        with self._node_lock:
            self._node[key] = value

    def update(self, node_data):
        print('%s update' % self.name)
        with self._node_lock:
            self._node = dict(node_data)

    def stop(self):
        self._is_run = False
        self._end_evt.set()

    def run(self):
        print('%s start' % self.name)
        ModbusClient()
        while self._is_run:
            print('read "%s"' % self.get_node('hostname'))

            self._end_evt.wait(MBUS_REFRESH)
        print('%s stop' % self.name)


# init connection to database
db_connect = pymysql.connect(host=DB_HOST,
                             user=DB_USER,
                             password=DB_PWD,
                             db=DB_NAME,
                             charset='utf8mb4',
                             cursorclass=pymysql.cursors.DictCursor,
                             autocommit=True)
db_cursor = db_connect.cursor()

# main loop
while True:
    # read nodes list on DB
    sql = """
    SELECT
        hosts.id AS host_id,
        hosts.hostname AS host_hostname,
        mbus.mbus_port AS mbus_port,
        mbus.mbus_timeout AS mbus_mbus_timeout,
        hosts.name AS host_name
    FROM
        `hosts`,
        `mbus`
    WHERE
        hosts.id = mbus.id_host
    AND
        mbus.mbus_inhibition = \'N\'
    AND
        hosts.host_activity = \'Y\'
    GROUP BY hosts.id"""
    db_cursor.execute(sql)
    nodes = db_cursor.fetchall()
    # update the node list
    node_list = {}
    for i in nodes:
        node_list[int(i['host_id'])] = dict(hostname=str(i['host_hostname'].encode('utf8')),
                                            port=int(i['mbus_port']),
                                            timeout=int(i['mbus_mbus_timeout']))
    NodeList.update_list(node_list)
    print('%d nodes' % len(nodes))
    # wait before next cycle
    time.sleep(1)
